{"meta":{"title":"Allen's World","subtitle":null,"description":"Great People Share Knowledge!","author":"Allen","url":"https://github.com/lygttpod"},"pages":[{"title":"about","date":"2017-10-19T06:42:58.000Z","updated":"2017-10-19T06:43:24.698Z","comments":true,"path":"about/index.html","permalink":"https://github.com/lygttpod/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-19T06:41:11.000Z","updated":"2017-10-19T06:41:35.355Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/lygttpod/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-19T06:17:06.000Z","updated":"2017-10-19T06:18:51.211Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/lygttpod/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RxJava+Retrofit 史上最精简封装（RxHttpUtils 2.x）使用说明","slug":"RxJava-Retrofit-史上最精简封装（RxHttpUtils-2-x）使用说明","date":"2017-08-29T08:25:05.000Z","updated":"2017-09-07T04:25:49.058Z","comments":true,"path":"2017/08/29/RxJava-Retrofit-史上最精简封装（RxHttpUtils-2-x）使用说明/","link":"","permalink":"https://github.com/lygttpod/2017/08/29/RxJava-Retrofit-史上最精简封装（RxHttpUtils-2-x）使用说明/","excerpt":"重磅推出 RxHttpUtils 2.x 版本RxJava+Retrofit封装，基于RxJava2和Retrofit2重构，便捷使用 上次封装的是基于RxJava1版本的，时隔半年多之后现在推出基于RxJava2的版本，相比上一版本提升不少，配置更加灵活，现在放出来供大家学习使用，使用过程中如有问题欢迎提出建议，不断完善这个库！ 添加Gradle依赖先在项目根目录的 build.gradle 的 repositories 添加:123456 allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 然后在dependencies添加: 1234dependencies &#123;... compile &apos;com.github.lygttpod:RxHttpUtils:2.0.1&apos;&#125;","text":"重磅推出 RxHttpUtils 2.x 版本RxJava+Retrofit封装，基于RxJava2和Retrofit2重构，便捷使用 上次封装的是基于RxJava1版本的，时隔半年多之后现在推出基于RxJava2的版本，相比上一版本提升不少，配置更加灵活，现在放出来供大家学习使用，使用过程中如有问题欢迎提出建议，不断完善这个库！ 添加Gradle依赖先在项目根目录的 build.gradle 的 repositories 添加:123456 allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 然后在dependencies添加: 1234dependencies &#123;... compile &apos;com.github.lygttpod:RxHttpUtils:2.0.1&apos;&#125; 使用说明1、使用前自己的application类必须继承BaseRxHttpApplication 继承BaseRxHttpApplication之后在自己的Application的onCreate方法中进行初始化配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyApplication extends BaseRxHttpApplication &#123; Map&lt;String, Object&gt; headerMaps = new HashMap&lt;&gt;(); @Override public void onCreate() &#123; super.onCreate(); headerMaps.put(&quot;header1&quot;, &quot;header1&quot;); headerMaps.put(&quot;header1&quot;, &quot;header1&quot;); /** * 全局请求的统一配置 */ RxHttpUtils .getInstance() //开启全局配置 .config() //全局的BaseUrl,必须配置(baseurl以 / 结尾) .setBaseUrl(BuildConfig.BASE_URL) //开启缓存策略 .setCache() //全局的请求头信息 .setHeaders(headerMaps) //全局持久话cookie,保存本地每次都会携带在header中 .setCookie(false) //全局ssl证书认证，支持三种方式 //1、信任所有证书,不安全有风险 .setSslSocketFactory() //2、使用预埋证书，校验服务端证书（自签名证书） //.setSslSocketFactory(getAssets().open(&quot;your.cer&quot;)) //3、使用bks证书和密码管理客户端证书（双向认证），使用预埋证书，校验服务端证书（自签名证书） //.setSslSocketFactory(getAssets().open(&quot;your.bks&quot;), &quot;123456&quot;, getAssets().open(&quot;your.cer&quot;)) //全局超时配置 .setReadTimeout(10) //全局超时配置 .setWriteTimeout(10) //全局超时配置 .setConnectTimeout(10) //全局是否打开请求log日志 .setLog(true); &#125;&#125; 2、自己定义的实体类必须继承BaseResponse基类123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by allen on 2017/6/23. * &lt;p&gt; * 请求结果基类 所有请求结果继承此类 */public class BaseResponse &#123; /** * 错误码 */ private int code; /** * 错误描述 */ private String msg; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; @Override public String toString() &#123; return &quot;BaseResponse&#123;&quot; + &quot;code=&quot; + code + &quot;, msg=&apos;&quot; + msg + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 代码实例—–具体参数意义请看下边的参数说明1、使用Application里边的全局配置参数的请求示例123456789101112131415161718192021RxHttpUtils .createApi(ApiService.class) .getBook() .compose(Transformer.&lt;BookBean&gt;switchSchedulers()) .subscribe(new CommonObserver&lt;BookBean&gt;() &#123; @Override protected void getDisposable(Disposable d) &#123; //方法暴露出来使用者根据需求去取消订阅 //d.dispose();在onDestroy方法中调用 &#125; @Override protected void onError(String errorMsg) &#123; //错误处理 &#125; @Override protected void onSuccess(BookBean bookBean) &#123; //业务处理 &#125; &#125;); 2、单个请求配置参数示例(可以根据需求选择性的配置)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//单个请求使用默认配置的参数RxHttpUtils .getSInstance() .baseUrl(&quot;https://api.douban.com/&quot;) .createSApi(ApiService.class) .getTop250(10) .compose(Transformer.&lt;Top250Bean&gt;switchSchedulers(loading_dialog)) .subscribe(new CommonObserver&lt;Top250Bean&gt;(loading_dialog) &#123; @Override protected void getDisposable(Disposable d) &#123; //方法暴露出来使用者根据需求去取消订阅 disposables.add(d); &#125; @Override protected void onError(String errorMsg) &#123; //错误处理 &#125; @Override protected void onSuccess(Top250Bean top250Bean) &#123; //业务处理 &#125; &#125;);//单个请求自己配置相关参数RxHttpUtils .getSInstance() .baseUrl(&quot;https://api.douban.com/&quot;) .addHeaders(headerMaps) .cache(true) .cachePath(&quot;cachePath&quot;, 1024 * 1024 * 100) .sslSocketFactory() .saveCookie(true) .writeTimeout(10) .readTimeout(10) .connectTimeout(10) .log(true) .createSApi(ApiService.class) .getTop250(10) .compose(Transformer.&lt;Top250Bean&gt;switchSchedulers(loading_dialog)) .subscribe(new CommonObserver&lt;Top250Bean&gt;(loading_dialog) &#123; @Override protected void getDisposable(Disposable d) &#123; //方法暴露出来使用者根据需求去取消订阅 disposables.add(d); &#125; @Override protected void onError(String errorMsg) &#123; //错误处理 &#125; @Override protected void onSuccess(Top250Bean top250Bean) &#123; //业务处理 &#125; &#125;); 3、链式请求–请求参数是上个请求的结果1234567891011121314151617181920212223242526272829RxHttpUtils .createApi(ApiService.class) .getBook() .flatMap(new Function&lt;BookBean, ObservableSource&lt;Top250Bean&gt;&gt;() &#123; @Override public ObservableSource&lt;Top250Bean&gt; apply(@NonNull BookBean bookBean) throws Exception &#123; return RxHttpUtils .createApi(ApiService.class) .getTop250(20); &#125; &#125;) .compose(Transformer.&lt;Top250Bean&gt;switchSchedulers(loading_dialog)) .subscribe(new CommonObserver&lt;Top250Bean&gt;(loading_dialog) &#123; @Override protected void getDisposable(Disposable d) &#123; //方法暴露出来使用者根据需求去取消订阅 disposables.add(d); &#125; @Override protected void onError(String errorMsg) &#123; //错误处理 &#125; @Override protected void onSuccess(Top250Bean top250Bean) &#123; //业务处理 &#125; &#125;); 4、文件下载 —-使用简单粗暴1234567891011121314151617181920212223242526String url = &quot;https://t.alipayobjects.com/L1/71/100/and/alipay_wap_main.apk&quot;;String fileName = &quot;alipay.apk&quot;;RxHttpUtils .downloadFile(url) .subscribe(new DownloadObserver(fileName) &#123; @Override protected void getDisposable(Disposable d) &#123; //方法暴露出来使用者根据需求去取消订阅 //d.dispose();在onDestroy方法中调用 &#125; @Override protected void onError(String errorMsg) &#123; &#125; @Override protected void onSuccess(long bytesRead, long contentLength, float progress, boolean done, String filePath) &#123; log.d(&quot;allen&quot;,&quot;下载中：&quot; + progress + &quot;%&quot;); if (done) &#123; showToast(&quot;下载完成---文件路径&quot;+filePath); &#125; &#125; &#125;); 参数说明 全局参数：在application中配置的参数都是以setXXX开头的,根据实际需求配置相应参数即可 12345678910111213141516171819202122232425//开启全局配置.config()//全局的BaseUrl.setBaseUrl(BuildConfig.BASE_URL)//开启缓存策略.setCache()//全局的请求头信息.setHeaders(headerMaps)//全局持久话cookie,保存本地每次都会携带在header中.setCookie(false)//全局ssl证书认证，支持三种方式//信任所有证书,不安全有风险.setSslSocketFactory()//使用预埋证书，校验服务端证书（自签名证书）//.setSslSocketFactory(getAssets().open(&quot;your.cer&quot;))//使用bks证书和密码管理客户端证书（双向认证），使用预埋证书，校验服务端证书（自签名证书）//.setSslSocketFactory(getAssets().open(&quot;your.bks&quot;), &quot;123456&quot;, getAssets().open(&quot;your.cer&quot;))//全局超时配置.setReadTimeout(10)//全局超时配置.setWriteTimeout(10)//全局超时配置.setConnectTimeout(10)//全局是否打开请求log日志.setLog(true); 单个请求参数：123456789101112131415161718192021222324252627//单个请求的实例getSInstance(getSingleInstance的缩写).getSInstance()//单个请求的baseUrl.baseUrl(&quot;https://api.douban.com/&quot;)//单个请求的header.addHeaders(headerMaps)//单个请求是否开启缓存.cache(true)//单个请求的缓存路径及缓存大小，不设置的话有默认值.cachePath(&quot;cachePath&quot;, 1024 * 1024 * 100)//单个请求的ssl证书认证，支持三种方式 //1、信任所有证书,不安全有风险.setSslSocketFactory() //2、使用预埋证书，校验服务端证书（自签名证书）//.setSslSocketFactory(getAssets().open(&quot;your.cer&quot;)) //3、使用bks证书和密码管理客户端证书（双向认证），使用预埋证书，校验服务端证书（自签名证书）//.setSslSocketFactory(getAssets().open(&quot;your.bks&quot;), &quot;123456&quot;, getAssets().open(&quot;your.cer&quot;))//单个请求是否持久化cookie.saveCookie(true)//单个请求超时.writeTimeout(10).readTimeout(10).connectTimeout(10)//单个请求是否开启log日志.log(true)//区分全局变量的请求createSApi(createSingleApi的缩写).createSApi(ApiService.class) 注意事项：适合请求结果是以下情况的（当然用户可以根据自己的实际需求稍微修改一下代码就能满足自己的需求） code为错误状态码 ; msg为错误描述信息 注意：请求成功时，msg字段可有可无。 { code: 0/400/401..., msg: 错误描述..., ... ... ... } 如果你的服务器返回不是以上格式不要惊慌，下载源码，源码其实很简单，自己重写一个BaseResponse基类，根据自己需求处理， 修改一下BaseObserver和ISubscriber中泛型继承的类就行了 后面会陆续完成文件上传的封装，敬请期待…如果遇到问题或者好的建议，请反馈到：issue、lygttpod@163.com 或者lygttpod@gmail.com 如果觉得对你有用的话，点一下右上的星星赞一下吧! 系列文章RXjava+Retrofit 史上最精简封装（RxHttpUtils 1.x）使用说明 RxJava+Retrofit 史上最精简封装（RxHttpUtils 2.x）如何封装 Demo下载地址 或者扫码下载demo","categories":[],"tags":[{"name":"Android 工具 封装 retrofit rxjava","slug":"Android-工具-封装-retrofit-rxjava","permalink":"https://github.com/lygttpod/tags/Android-工具-封装-retrofit-rxjava/"}]},{"title":"SuperTextView 万能android布局工具类","slug":"SuperTextView-万能android布局工具类","date":"2017-08-29T08:19:08.000Z","updated":"2017-09-07T04:23:02.099Z","comments":true,"path":"2017/08/29/SuperTextView-万能android布局工具类/","link":"","permalink":"https://github.com/lygttpod/2017/08/29/SuperTextView-万能android布局工具类/","excerpt":"SuperTextView 重磅推出SuperTextView2.x版本，属性参数相比1.x有些变化，1.x的用户升级2.x的时候请注意1、功能描述 SuperTextView是一个功能强大的View，可以满足日常大部分布局样式，开发者可已自行组合属性配置出属于自己风格的样式!可能描述起来没有概念，还是直接看效果图吧！ SuperButton拥有shape文件的大部分属性，从此写shape属性变得非常简单 CommonTextView只是SuperTextView的逻辑简化，其实功能并不差少哦，有兴趣的可以看看 如果觉得对你有用的话，点一下右上的星星赞一下吧!","text":"SuperTextView 重磅推出SuperTextView2.x版本，属性参数相比1.x有些变化，1.x的用户升级2.x的时候请注意1、功能描述 SuperTextView是一个功能强大的View，可以满足日常大部分布局样式，开发者可已自行组合属性配置出属于自己风格的样式!可能描述起来没有概念，还是直接看效果图吧！ SuperButton拥有shape文件的大部分属性，从此写shape属性变得非常简单 CommonTextView只是SuperTextView的逻辑简化，其实功能并不差少哦，有兴趣的可以看看 如果觉得对你有用的话，点一下右上的星星赞一下吧! 2、 效果 Demo下载地址 3、如何使用3.1、Android Studio导入方法，添加Gradle依赖 先在项目根目录的 build.gradle 的 repositories 添加:123456 allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 然后在dependencies添加:1234dependencies &#123;... compile &apos;com.github.lygttpod:SuperTextView:2.1.3&apos;&#125; 重写SuperTextView，功能更加全面，部分方法及属性有变更，1.x版本的老用户请注意 3.2、项目中如何使用3.2.1、布局中如何使用（示例中只列出部分属性，开发者可根据具体需求使用其他属性）12345678910111213141516&lt;com.allen.library.SuperTextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot; stv:sCenterBottomTextColor=&quot;@color/colorAccent&quot; stv:sCenterBottomTextString=&quot;限额说明&gt;&gt;&quot; stv:sCenterTopTextString=&quot; &quot; stv:sCenterViewGravity=&quot;left_center&quot; stv:sLeftBottomTextString=&quot;招商银行（8888）&quot; stv:sLeftIconRes=&quot;@drawable/bank_zhao_shang&quot; stv:sLeftTopTextString=&quot;银行卡支付&quot; stv:sLeftViewGravity=&quot;left_center&quot; stv:sRightCheckBoxRes=&quot;@drawable/circular_check_bg&quot; stv:sRightViewType=&quot;checkbox&quot; /&gt; 注意： 1、上下的线可以通过 sDividerLineType 设置 有四种显示方式 none，top，bottom，both 2、通过设置 sUseRipple=true 开启水波效果 3.2.2、代码中如何使用123456789101112131415161718192021222324252627282930313233343536 /** * 可以通过链式设置大部分常用的属性值 */superTextView.setLeftTopString(&quot;&quot;) .setLeftString(&quot;&quot;) .setLeftBottomString(&quot;&quot;) .setCenterTopString(&quot;&quot;) .setCenterString(&quot;&quot;) .setCenterBottomString(&quot;&quot;) .setRightTopString(&quot;&quot;) .setRightString(&quot;&quot;) .setRightBottomString(&quot;&quot;) .setLeftIcon(0) .setRightIcon(0) .setCbChecked(true) .setCbBackground(null) .setLeftTvDrawableLeft(null) .setLeftTvDrawableRight(null) .setCenterTvDrawableLeft(null) .setCenterTvDrawableRight(null) .setRightTvDrawableLeft(null) .setRightTvDrawableRight(null); superTextView.setShapeCornersRadius(20) .setShapeCornersTopLeftRadius(20) .setShapeCornersBottomLeftRadius(20) .setShapeCornersTopRightRadius(20) .setShapeCornersBottomRightRadius(20) .setShapeStrokeColor(getResources().getColor(R.color.colorPrimary)) .setShapeStrokeWidth(1) .setShapeSrokeDashWidth(1) .setShapeStrokeDashGap(5) .setShapeSolidColor(getResources().getColor(R.color.white)) .setShapeSelectorNormalColor(getResources().getColor(R.color.red_btn)) .setShapeSelectorPressedColor(getResources().getColor(R.color.gray)) .useShape();//设置完各个参数之后这句调用才生效 3.2.3点击事件（可根据需求选择实现单个或者多个点击事件）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 根据实际需求对需要的View设置点击事件 *//** * 根据实际需求对需要的View设置点击事件 */superTextView.setOnSuperTextViewClickListener(new SuperTextView.OnSuperTextViewClickListener() &#123; @Override public void onClickListener(SuperTextView superTextView) &#123; string = &quot;整个item的点击事件&quot;; Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setLeftTopTvClickListener(new SuperTextView.OnLeftTopTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getLeftTopString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setLeftTvClickListener(new SuperTextView.OnLeftTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getLeftString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setLeftBottomTvClickListener(new SuperTextView.OnLeftBottomTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getLeftBottomString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setCenterTopTvClickListener(new SuperTextView.OnCenterTopTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getCenterTopString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setCenterTvClickListener(new SuperTextView.OnCenterTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getCenterString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setCenterBottomTvClickListener(new SuperTextView.OnCenterBottomTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getCenterBottomString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setRightTopTvClickListener(new SuperTextView.OnRightTopTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getRightTopString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setRightTvClickListener(new SuperTextView.OnRightTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getRightString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setRightBottomTvClickListener(new SuperTextView.OnRightBottomTvClickListener() &#123; @Override public void onClickListener() &#123; string = superTextView.getRightBottomString(); Toast.makeText(ClickActivity.this, string, Toast.LENGTH_SHORT).show(); &#125;&#125;).setLeftImageViewClickListener(new SuperTextView.OnLeftImageViewClickListener() &#123; @Override public void onClickListener(ImageView imageView) &#123; Toast.makeText(ClickActivity.this, &quot;左边图片&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;).setRightImageViewClickListener(new SuperTextView.OnRightImageViewClickListener() &#123; @Override public void onClickListener(ImageView imageView) &#123; Toast.makeText(ClickActivity.this, &quot;右边图片&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125;);superTextView_cb.setOnSuperTextViewClickListener(new SuperTextView.OnSuperTextViewClickListener() &#123; @Override public void onClickListener(SuperTextView superTextView) &#123; superTextView.setCbChecked(!superTextView.getCbisChecked()); &#125;&#125;).setCheckBoxCheckedChangeListener(new SuperTextView.OnCheckBoxCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Toast.makeText(ClickActivity.this, &quot;&quot; + isChecked, Toast.LENGTH_SHORT).show(); &#125;&#125;);superTextView_switch.setOnSuperTextViewClickListener(new SuperTextView.OnSuperTextViewClickListener() &#123; @Override public void onClickListener(SuperTextView superTextView) &#123; superTextView.setSwitchIsChecked(!superTextView.getSwitchIsChecked()); &#125;&#125;).setSwitchCheckedChangeListener(new SuperTextView.OnSwitchCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Toast.makeText(ClickActivity.this, &quot;&quot; + isChecked, Toast.LENGTH_SHORT).show(); &#125;&#125;); 3.2.4使用第三方库(Picasso或者Glide)加载网络图片1234567891011121314151617181920212223String url1 = &quot;https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3860616424,1789830124&amp;fm=80&amp;w=179&amp;h=119&amp;img.PNG&quot;;String url2 = &quot;https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=219781665,3032880226&amp;fm=80&amp;w=179&amp;h=119&amp;img.JPEG&quot;;String url3 = &quot;https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3860616424,1789830124&amp;fm=80&amp;w=179&amp;h=119&amp;img.PNG&quot;;Picasso.with(this) .load(url1) .placeholder(R.drawable.head_default) .into(superTextView.getLeftIconIV());Glide.with(this) .load(url2) .placeholder(R.drawable.head_default) .fitCenter() .into(superTextView2.getRightIconIV());Glide.with(this) .load(url3) .placeholder(R.drawable.head_default) .into(new SimpleTarget&lt;GlideDrawable&gt;() &#123; @Override public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123; superTextView3.setRightTvDrawableRight(resource); &#125; &#125;); 3.2.5、属性说明(以下属性全部可以通过xml文件配置和代码进行设置) 属性名 字段 描述 默认值 sLeftTextString string 左边文字字符串 sLeftTopTextString string 左上文字字符串 sLeftBottomTextString string 左下文字字符串 sCenterTextString string 中间文字字符串 sCenterTopTextString string 中上文字字符串 sCenterBottomTextString string 中下文字字符串 sRightTextString string 右边文字字符串 sRightTopTextString string 右上文字字符串 sRightBottomTextString string 右下文字字符串 sLeftTextColor color 左边文字颜色 默认0xFF373737 sLeftTopTextColor color 左上文字颜色 默认0xFF373737 sLeftBottomTextColor color 左下文字颜色 默认0xFF373737 sCenterTextColor color 中间文字颜色 默认0xFF373737 sCenterTopTextColor color 中上文字颜色 默认0xFF373737 sCenterBottomTextColor color 中下文字颜色 默认0xFF373737 sRightTextColor color 左边文字颜色 默认0xFF373737 sRightTopTextColor color 右上文字颜色 默认0xFF373737 sRightBottomTextColor color 右下文字颜色 默认0xFF373737 sLeftTextSize dimension 左边字体大小 默认15sp sLeftTopTextSize dimension 左上字体大小 默认15sp sLeftBottomTextSize dimension 左下字体大小 默认15sp sCenterTextSize dimension 中间字体大小 默认15sp sCenterTopTextSize dimension 中上字体大小 默认15sp sCenterBottomTextSize dimension 中下字体大小 默认15sp sRightTextSize dimension 右边字体大小 默认15sp sRightTopTextSize dimension 右上字体大小 默认15sp sRightBottomTextSize dimension 右下字体大小 默认15sp sLeftLines integer 左边文字显示行数 默认1 sLeftTopLines integer 左上文字显示行数 默认1 sLeftBottomLines integer 左下文字显示行数 默认1 sCenterLines integer 中间文字显示行数 默认1 sCenterTopLines integer 中上文字显示行数 默认1 sCenterBottomLines integer 中下文字显示行数 默认1 sRightLines integer 右边文字显示行数 默认1 sRightTopLines integer 右上文字显示行数 默认1 sRightBottomLines integer 右下文字显示行数 默认1 sLeftMaxEms integer 左边文字显示个数 默认15 sLeftTopMaxEms integer 左上文字显示个数 默认15 sLeftBottomMaxEms integer 左下文字显示个数 默认15 sCenterMaxEms integer 中间文字显示个数 默认15 sCenterTopMaxEms integer 中上文字显示个数 默认15 sCenterBottomMaxEms integer 中下文字显示个数 默认15 sRightMaxEms integer 右边文字显示个数 默认15 sRightTopMaxEms integer 右上文字显示个数 默认15 sRightBottomMaxEms integer 右下文字显示个数 默认15 sLeftViewGravity enum 左边文字对齐方式left_center(左对齐)center(居中)right_center(右对齐) 默认center sCenterViewGravity enum 中间文字对齐方式left_center(左对齐)center(居中)right_center(右对齐) 默认center sRightViewGravity enum 右边文字对齐方式left_center(左对齐)center(居中)right_center(右对齐) 默认center sLeftTvDrawableLeft reference 左边TextView左侧的drawable sLeftTvDrawableRight reference 左边TextView右侧的drawable sCenterTvDrawableLeft reference 中间TextView左侧的drawable sCenterTvDrawableRight reference 中间TextView右侧的drawable sRightTvDrawableLeft reference 右边TextView左侧的drawable sRightTvDrawableRight reference 右边TextView右侧的drawable sLeftTvDrawableWidth dimension 左边TextView的drawable的宽度 sLeftTvDrawableHeight dimension 左边TextView的drawable的高度 sCenterTvDrawableWidth dimension 中间TextView的drawable的宽度 sCenterTvDrawableHeight dimension 中间TextView的drawable的高度 sRightTvDrawableWidth dimension 右边TextView的drawable的宽度 sRightTvDrawableHeight dimension 右边TextView的drawable的高度 sTextViewDrawablePadding dimension TextView的drawable对应的Padding 默认10dp sLeftViewWidth dimension 左边textView的宽度 为了中间文字左对齐的时候使用 sTopDividerLineMarginLR dimension 上边分割线的MarginLeft和MarginRight 默认0dp sTopDividerLineMarginLeft dimension 上边分割线的MarginLeft 默认0dp sTopDividerLineMarginRight dimension 上边分割线的MarginRight 默认0dp sBottomDividerLineMarginLR dimension 下边分割线的MarginLeft和MarginRigh 默认0dp sBottomDividerLineMarginLeft dimension 下边分割线的MarginLeft 默认0dp sBottomDividerLineMarginRight dimension 下边分割线的MarginRight 默认0dp sDividerLineColor color 分割线的颜色 默认0xFFE8E8E8 sDividerLineHeight dimension 分割线的高度 默认0.5dp sDividerLineType enum 分割线显示方式 none(不显示分割线)top(显示上边的分割线)bottom(显示下边的分割线)both(显示上下两条分割线) 默认bottom sLeftViewMarginLeft dimension 左边view的MarginLeft 默认10dp sLeftViewMarginRight dimension 左边view的MarginRight 默认10dp sCenterViewMarginLeft dimension 中间view的MarginLeft 默认10dp sCenterViewMarginRight dimension 中间view的MarginRight 默认10dp sRightViewMarginLeft dimension 右边view的MarginLeft 默认10dp sRightViewMarginRight dimension 右边view的MarginRight 默认10dp sLeftTextIsBold boolean 左边文字是否加粗 默认false sLeftTopTextIsBold boolean 左上文字是否加粗 默认false sLeftBottomTextIsBold boolean 左下文字是否加粗 默认false sCenterTextIsBold boolean 中间文字是否加粗 默认false sCenterTopTextIsBold boolean 中上文字是否加粗 默认false sCenterBottomTextIsBold boolean 中下文字是否加粗 默认false sRightTextIsBold boolean 右边文字是否加粗 默认false sRightTopTextIsBold boolean 右上文字是否加粗 默认false sRightBottomTextIsBold boolean 右下文字是否加粗 默认false sLeftIconRes reference 左边图片资源 可以用来显示网络图片或者本地 sRightIconRes reference 右边图片资源 可以用来显示网络图片或者本地 sLeftIconWidth dimension 左边图片资源的宽度 用于固定图片大小的时候使用 sLeftIconHeight dimension 左边图片资源的高度 用于固定图片大小的时候使用 sRightIconWidth dimension 右边图片资源的宽度 用于固定图片大小的时候使用 sRightIconHeight dimension 右边图片资源的高度 用于固定图片大小的时候使用 sLeftIconMarginLeft dimension 左边图片资源的MarginLeft 默认10dp sRightIconMarginRight dimension 右边图片资源的MarginLeft 默认10dp sCenterSpaceHeight dimension 上中下三行文字的间距 默认5dp sRightCheckBoxRes reference 右边CheckBox的资源 sRightCheckBoxMarginRight dimension 右边CheckBox的MarginRight 默认10dp sIsChecked boolean 右边CheckBox是否选中 默认 false sUseRipple boolean 是否开启点击出现水波效果 默认 true sBackgroundDrawableRes reference SuperTextView的背景资源 sRightViewType enum 右边显示的特殊ViewcheckboxswitchBtn 默认都不显示 sRightSwitchMarginRight dimension 右边SwitchBtn的MarginRight 默认10dp sSwitchIsChecked boolean 右边SwitchBtn是否选中 默认 false sTextOff string TextOff 默认”” sTextOn string TextOn 默认”” sSwitchMinWidth dimension SwitchMinWidth 系统默认 sSwitchPadding dimension SwitchPadding 系统默认 sThumbTextPadding dimension ThumbTextPadding 系统默认 sThumbResource reference 右边SwitchBtn自定义选中资源 系统默认 sTrackResource reference 右边SwitchBtn自定义未选中资源 系统默认 sUseShape boolean 是否使用shape设置圆角及触摸反馈设为true之后才能使用一下属性 默认false sShapeSolidColor color 填充色 默认false sShapeSelectorPressedColor color 按下时候的颜色 默认0xffffffff sShapeSelectorNormalColor color 正常显示的颜色 默认0xffffffff sShapeCornersRadius dimension 四个角的圆角半径 默认0dp sShapeCornersTopLeftRadius dimension 左上角的圆角半径 默认0dp sShapeCornersTopRightRadius dimension 右上角的圆角半径 默认0dp sShapeCornersBottomLeftRadius dimension 左下角的圆角半径 默认0dp sShapeCornersBottomRightRadius dimension 右下角的圆角半径 默认0dp sShapeStrokeWidth dimension 边框宽度 默认0dp sShapeStrokeDashWidth dimension 虚线宽度 默认0dp sShapeStrokeDashGap dimension 虚线间隙宽度 默认0dp sShapeStrokeColor color 边框颜色 默认0dp sLeftTextBackground reference 左边textView的背景 sCenterTextBackground reference 中间textView的背景 sRightTextBackground reference 右边textView的背景 黑格尔曾说过：存在即合理。SuperTextView的出现应该就是某种需求下的产物。 4、更新日志意见反馈如果遇到问题或者好的建议，请反馈到：issue、lygttpod@163.com 或者lygttpod@gmail.com 如果觉得对你有用的话，点一下右上的星星赞一下吧! 代码是最好的老师，更多详细用法请查看 demo:feet:打赏支持如果您觉得 SuperTextView 开源库帮你节省了大量的开发时间，请扫描下方的二维码随意打赏，要是能打赏个 10.24 :monkey_face:就太:thumbsup:了。您的支持将鼓励我继续创作:octocat:","categories":[],"tags":[{"name":"Android 库文件 SuperTextView","slug":"Android-库文件-SuperTextView","permalink":"https://github.com/lygttpod/tags/Android-库文件-SuperTextView/"}]},{"title":"Android实用View系列之SuperButton（实现shape的大部分功能）","slug":"Android实用View系列之SuperButton（实现shape的大部分功能）","date":"2017-07-11T08:24:34.000Z","updated":"2017-09-07T04:25:06.675Z","comments":true,"path":"2017/07/11/Android实用View系列之SuperButton（实现shape的大部分功能）/","link":"","permalink":"https://github.com/lygttpod/2017/07/11/Android实用View系列之SuperButton（实现shape的大部分功能）/","excerpt":"在开发过程中我们的按钮基本都有自己的样式风格，有的时候需要搞个圆角，有时候需要边框，有的时候需要虚线边框亦或者需要一个圆形的按钮。想大部分的实现方式都是写一个shape文件，在里边定义边框圆角等相关属性，如果项目中类似按钮很多切风格各不相同，那我们就需要写很多很多shape文件，这是我们无法忍受的。而SuperButton的出现可以帮你解决以上问题，从此远离shape文件的编写。 有图有真相 github源码地址传送门","text":"在开发过程中我们的按钮基本都有自己的样式风格，有的时候需要搞个圆角，有时候需要边框，有的时候需要虚线边框亦或者需要一个圆形的按钮。想大部分的实现方式都是写一个shape文件，在里边定义边框圆角等相关属性，如果项目中类似按钮很多切风格各不相同，那我们就需要写很多很多shape文件，这是我们无法忍受的。而SuperButton的出现可以帮你解决以上问题，从此远离shape文件的编写。 有图有真相 github源码地址传送门 开篇开始之前我们先来看看shape文件是如何编写的12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt; &lt;corners android:radius=&quot;integer&quot; android:topLeftRadius=&quot;integer&quot; android:topRightRadius=&quot;integer&quot; android:bottomLeftRadius=&quot;integer&quot; android:bottomRightRadius=&quot;integer&quot; /&gt; &lt;gradient android:angle=&quot;integer&quot; android:centerX=&quot;integer&quot; android:centerY=&quot;integer&quot; android:centerColor=&quot;integer&quot; android:endColor=&quot;color&quot; android:gradientRadius=&quot;integer&quot; android:startColor=&quot;color&quot; android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;] android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt; &lt;size android:width=&quot;integer&quot; android:height=&quot;integer&quot; /&gt; &lt;solid android:color=&quot;color&quot; /&gt; &lt;stroke android:width=&quot;integer&quot; android:color=&quot;color&quot; android:dashWidth=&quot;integer&quot; android:dashGap=&quot;integer&quot; /&gt;&lt;/shape&gt; 以上shape文件列出了常用的属性，当然并不是所有属性都会用到，我们就以这个shape文件作为参考开始本篇文章的分析。 我们知道写好shape文件之后是通过android:background=”@drawable/shape”这样的方式引入的，那么Android有没有方法去获取shape相关属性的类呐，经过一番查阅发现还是有个GradientDrawable类可以实现的，关于GradientDrawable的介绍请自行Google了解。 通过GradientDrawable的源码可以看到里边有很多方法和shape各个节点的名称一样，所以这正是我们需要的类，剩下的就是开始用GradientDrawable实现我们的封装之路。 具体实现由于代码不复杂，看下注释也都能理解，就直接贴代码了 先初始化一下gradientDrawable = new GradientDrawable(); 1234567891011121314151617181920/** * 设置shape类型，对应shape的四个属性 */ private void setShape() &#123; switch (shapeType) &#123; case RECTANGLE: gradientDrawable.setShape(GradientDrawable.RECTANGLE); break; case OVAL: gradientDrawable.setShape(GradientDrawable.OVAL); break; case LINE: gradientDrawable.setShape(GradientDrawable.LINE); break; case RING: gradientDrawable.setShape(GradientDrawable.RING); break; &#125; &#125; 通过一下方法可以整体设置四个圆角也可以对各个角分别设置 123456789101112131415161718192021/** * 只有类型是矩形的时候设置圆角半径才有效 */private void setRadius() &#123; if (shapeType == GradientDrawable.RECTANGLE) &#123; if (cornersRadius != 0) &#123; gradientDrawable.setCornerRadius(dip2px(mContext, cornersRadius));//设置圆角的半径 &#125; else &#123; //1、2两个参数表示左上角，3、4表示右上角，5、6表示右下角，7、8表示左下角 gradientDrawable.setCornerRadii( new float[] &#123; cornersTopLeftRadius, cornersTopLeftRadius, cornersTopRightRadius, cornersTopRightRadius, cornersBottomRightRadius, cornersBottomRightRadius, cornersBottomLeftRadius, cornersBottomLeftRadius &#125; ); &#125; &#125;&#125; 设置渐变色的相关属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 设置背景颜色 * 如果设定的有Orientation 就默认为是渐变色的Button，否则就是纯色的Button */private void setOrientation() &#123; if (gradientOrientation != -1) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; gradientDrawable.setOrientation(getOrientation(gradientOrientation)); if (gradientCenterColor == -1) &#123; gradientDrawable.setColors(new int[]&#123;gradientStartColor, gradientEndColor&#125;); &#125; else &#123; gradientDrawable.setColors(new int[]&#123;gradientStartColor, gradientCenterColor, gradientEndColor&#125;); &#125; switch (gradientType) &#123; case linear: gradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT); break; case radial: gradientDrawable.setGradientType(GradientDrawable.RADIAL_GRADIENT); gradientDrawable.setGradientRadius(gradientGradientRadius); break; case sweep: gradientDrawable.setGradientType(GradientDrawable.SWEEP_GRADIENT); break; &#125; gradientDrawable.setUseLevel(gradientUseLevel); if (gradientCenterX != 0 &amp;&amp; gradientCenterY != 0) &#123; gradientDrawable.setGradientCenter(gradientCenterX, gradientCenterY); &#125; &#125; &#125; else &#123; gradientDrawable.setColor(solidColor); &#125;&#125;/** * 设置颜色渐变类型 * * @param gradientOrientation gradientOrientation * @return Orientation */private GradientDrawable.Orientation getOrientation(int gradientOrientation) &#123; GradientDrawable.Orientation orientation = null; switch (gradientOrientation) &#123; case TOP_BOTTOM: orientation = GradientDrawable.Orientation.TOP_BOTTOM; break; case TR_BL: orientation = GradientDrawable.Orientation.TR_BL; break; case RIGHT_LEFT: orientation = GradientDrawable.Orientation.RIGHT_LEFT; break; case BR_TL: orientation = GradientDrawable.Orientation.BR_TL; break; case BOTTOM_TOP: orientation = GradientDrawable.Orientation.BOTTOM_TOP; break; case BL_TR: orientation = GradientDrawable.Orientation.BL_TR; break; case LEFT_RIGHT: orientation = GradientDrawable.Orientation.LEFT_RIGHT; break; case TL_BR: orientation = GradientDrawable.Orientation.TL_BR; break; &#125; return orientation;&#125; 对应shape中的size设置shape布局大小及设置边框和分割线123456789101112131415/** 设置size的值*/ private void setSize() &#123; if (shapeType == RECTANGLE) &#123; gradientDrawable.setSize(sizeWidth, sizeHeight); &#125; &#125; /** * 设置边框 宽度 颜色 虚线 间隙 */ private void setBorder() &#123; gradientDrawable.setStroke(dip2px(mContext, strokeWidth), strokeColor, strokeDashWidth, strokeDashGap); &#125; 至此需要的方法都已经写完了，剩下的就是自定义view继承button，添加自己定义的属性 然后在代码中这样使用12345678&lt;com.allen.library.SuperButton android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_margin=&quot;5dp&quot; android:text=&quot;圆角边框&quot; stv:sCornersRadius=&quot;5dp&quot; stv:sStrokeColor=&quot;@color/colorAccent&quot; stv:sStrokeWidth=&quot;0.2dp&quot; /&gt; 通过配置shapeType的类型可以以此实现矩形，椭圆，线和圆环 至此关于shape代码实现的部分已经完成了，可以实现shape很多中效果，不过细心的你发现按钮按下的触摸反馈没有了，以前都是通过selector去实现的，那么代码能否实现呐。答案肯定是OK啦1234567891011121314151617/** * 获取设置之后的Selector * * @return stateListDrawable */public StateListDrawable getSelector() &#123; StateListDrawable stateListDrawable = new StateListDrawable(); //注意该处的顺序，只要有一个状态与之相配，背景就会被换掉 //所以不要把大范围放在前面了，如果sd.addState(new[]&#123;&#125;,normal)放在第一个的话，就没有什么效果了 stateListDrawable.addState(new int[]&#123;android.R.attr.state_pressed, android.R.attr.state_enabled&#125;, getDrawable(android.R.attr.state_pressed)); stateListDrawable.addState(new int[]&#123;-android.R.attr.state_enabled&#125;, getDrawable(-android.R.attr.state_enabled)); stateListDrawable.addState(new int[]&#123;&#125;, getDrawable(android.R.attr.state_enabled)); return stateListDrawable;&#125; 然后把selector设置到setBackground中就好了12345if (Build.VERSION.SDK_INT &lt; 16) &#123; setBackgroundDrawable(useSelector ? getSelector() : getDrawable(0)); &#125; else &#123; setBackground(useSelector ? getSelector() : getDrawable(0)); &#125; 在运行一下，看看效果 最后看了以上介绍是不是感觉很简单，那就赶快撸起袖子，自己撸一个玩玩吧！毕竟以后不用在写那么多shape文件了，哈哈！以后可以少搬点砖了","categories":[],"tags":[{"name":"Android View 自定义","slug":"Android-View-自定义","permalink":"https://github.com/lygttpod/tags/Android-View-自定义/"}]},{"title":"Android实用View------水波动画效果多种实现方式详解","slug":"Android实用View-水波动画效果多种实现方式详解","date":"2017-06-20T08:24:12.000Z","updated":"2017-09-07T04:22:40.739Z","comments":true,"path":"2017/06/20/Android实用View-水波动画效果多种实现方式详解/","link":"","permalink":"https://github.com/lygttpod/2017/06/20/Android实用View-水波动画效果多种实现方式详解/","excerpt":"这次给大家带来的是一篇关于自定义View实现水波动画效果的文章，其实在去年项目中使用过类似的动画，当时就自定义View也实现了预期的效果，最近项目中又使用了相似的效果，于是对代码重新整理了一下并且记录下来，便于以后有类似需求可以当作参考！ 按照惯例，无图无真相 实现方式：1、正余弦函数实现2、贝塞尔曲线实现 开篇看到上边的两种实现方式是不是感觉都和数学公式有关呐，这对于毕业多年之后的我们来说如果当初数学基础不是很好现在估计也全部还给老师了吧，所以一提到相关的数学计算公式只能用一个表情表达了。。。","text":"这次给大家带来的是一篇关于自定义View实现水波动画效果的文章，其实在去年项目中使用过类似的动画，当时就自定义View也实现了预期的效果，最近项目中又使用了相似的效果，于是对代码重新整理了一下并且记录下来，便于以后有类似需求可以当作参考！ 按照惯例，无图无真相 实现方式：1、正余弦函数实现2、贝塞尔曲线实现 开篇看到上边的两种实现方式是不是感觉都和数学公式有关呐，这对于毕业多年之后的我们来说如果当初数学基础不是很好现在估计也全部还给老师了吧，所以一提到相关的数学计算公式只能用一个表情表达了。。。 1、正余弦函数实现正余弦的函数不知道大家还记不记得，我们温习一下相关参数的意义12345y=A*sin(ωx+φ)+k A—振幅越大，波形在y轴上最大与最小值的差值越大 ω—角速度， 控制正弦周期(单位角度内震动的次数) φ—初相，反映在坐标系上则为图像的左右移动。这里通过不断改变φ,达到波浪移动效果 k—偏距，反映在坐标系上则为图像的上移或下移。 我们要实现移动的波形首先是先画出静态的波形，那么怎么来绘制一个波形图呐，Math函数里已经提供了相应的方法，我们可以直接使用 A Math.sin(ω x + φ ) + K)开始绘制之前首先定义相关画笔之类的参数，在此就不做过多说明了，根据上边的公式我们知道需要哪些参数，首先是A，这是振幅，就是波形最高和最低点的差值，我们可以设置定值或者外界传入；其次是ω，角速度，给一个定制或者外界传入；φ，相位，我们就是根据不断改变相位来达到波形移动的效果，每次移动多少可以从外界传入，便于控制速度；K，波形偏移上下的距离，知道了以上各个参数的具体使用意义，下边就可以直接通过代码看下具体实现效果了，毕竟公式都有了，参数也发给你了，剩下的就是根据公式填写以下相应参数就ok了 12345678910111213141516private void drawSin(Canvas canvas) &#123; φ -= 0.03; float y; path.reset(); path.moveTo(0, getHeight()); for (float x = 0; x &lt;= getWidth(); x += 20) &#123; y = (float) (A * Math.sin(ω * x + φ ) + K); path.lineTo(x, getHeight() - y); &#125; canvas.drawPath(path, paint); &#125; 静态的波形出来之后我们就要借助属性动画来让波形动起来123456789101112131415161718private void initAnimation() &#123; valueAnimator = ValueAnimator.ofInt(0, getWidth()); valueAnimator.setDuration(1000); valueAnimator.setRepeatCount(ValueAnimator.INFINITE); valueAnimator.setInterpolator(new LinearInterpolator()); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; /** * 刷新页面调取onDraw方法，通过变更φ 达到移动效果 */ invalidate(); &#125; &#125;); if (waveStart) &#123; valueAnimator.start(); &#125;&#125; 开启动画之后再运行一下看看效果吧 看到这里只是一个单纯的波形，我们一般使用的时候并不是这样的，而是一个封闭的波形，可以向上封闭也可以向下封闭，我们在波形绘制完成之后12345.........省略部分代码//填充矩形 path.lineTo(getWidth(), getHeight()); path.lineTo(0, getHeight()); path.close(); 这样就绘制出封闭的波形了，然后画笔设成填充就ok 代码中我已经对向下密封还是向上密封封装了方法，在此就不再赘述，需要的可以看源码哦，除此之外还有其他的参数都进行了可配置话，可以通过xml进行设置，至此通过正余弦函数进行绘制波形图已经介绍完毕了。 2、贝塞尔曲线实现对贝塞尔曲线不是很了解的可以自行百度，概念性的东东就不在此赘述，我们使用二阶的贝塞尔进行绘制，为什么选择二阶的呐，看一个图就知道啦 一段完整的波形其实就是两个二阶的贝塞尔组成的，来看下代码12345678910111213141516171819202122232425262728293031323334/** * sin函数图像的波形 * * @param canvas */private void drawSinPath(Canvas canvas) &#123; mWavePath.reset(); mWavePath.moveTo(-mWaveLength + mOffset, mWaveAmplitude); //相信很多人会疑惑为什么控制点的纵坐标是以下值, //是根据公式计算出来的,具体计算方法情况文章内容 for (int i = 0; i &lt; mWaveCount; i++) &#123; //第一个控制点的坐标为(-mWaveLength * 3 / 4,-mWaveAmplitude) mWavePath.quadTo(-mWaveLength * 3 / 4 + mOffset + i * mWaveLength, -mWaveAmplitude, -mWaveLength / 2 + mOffset + i * mWaveLength, mWaveAmplitude); //第二个控制点的坐标为(-mWaveLength / 4,3 * mWaveAmplitude) mWavePath.quadTo(-mWaveLength / 4 + mOffset + i * mWaveLength, 3 * mWaveAmplitude, mOffset + i * mWaveLength, mWaveAmplitude); &#125; mWavePath.lineTo(getWidth(), getHeight()); mWavePath.lineTo(0, getHeight()); mWavePath.close(); canvas.drawPath(mWavePath, mWavePaint);&#125; 根据计算得到起点和控制点坐标之后就可以写代码运行了效果和上边的运行效果一样就不再展示了，上边的计算内容就解释了代码提出的问题 3、两种方式对比总结图像的绘制其实都不复杂，不过关键点还是有几个的。正余弦函数的波形使用是根据相位控制的，而贝塞尔曲线实现的波形效果是不断改变波的起始位置控制的，并且使用贝塞尔曲线的话需要先在屏幕外边绘制一个完整的波形，保证在平移的过程中可以看到图像不间断的移动来达到移动的波形效果。 最后看到这里你是你会感觉到这边文章的内容其实很简单，只要中间的几个点注意一下就可以实现相应的效果了，建议朋友们动手敲一遍代码，加深一下印象，毕竟真是做出来和知道理论没有实践还是有很大区别的！ github源码地址传送门 谨以此篇来记录自己项目中遇到的问题，献给需要类似功能的小伙伴们。如果你有好的建议欢迎评论指出，大家一起讨论、学习、进步！","categories":[],"tags":[]},{"title":"Android实用View系列------TextView实现打印机效果","slug":"Android实用View系列-TextView实现打印机效果","date":"2017-06-11T08:23:57.000Z","updated":"2017-09-07T04:24:31.025Z","comments":true,"path":"2017/06/11/Android实用View系列-TextView实现打印机效果/","link":"","permalink":"https://github.com/lygttpod/2017/06/11/Android实用View系列-TextView实现打印机效果/","excerpt":"在审美疲劳的今天，如何能开发出一款应用让用户耳目一新呐，适当的动画特效能为你的APP加分不少，这一点在海外的APP上表现颇为明显。今天为大家带来一篇实用的自定义view，就是是TextView实现文字逐个显示（类似打印机打字一样，逐个显示的效果）。 按照惯例，无图无真相 1、开篇在开始讲解之前先问一下大家，看到这样的一个动画效果，脑海中首先先闪的思路是什么，如果你的UI设计师让你去实现的话，你要怎么做呐，希望读者在思考片刻之后再继续阅读，看看我们的设计思路是不是一样，如果不一样比较一下哪种实现起来更方便，哪种效率更高，欢迎评论交流。你有一个思想，我有一个思想，交换一下我们都有两个思想。 当你读到这里的时候说明你应该思考过上边的问题了，就问你第一想法是不是网上搜相关资料，看看有没有现成的，有的话直接拿来，没的话换个方式继续搜索。。。比如到各个开发群里询问有没有类似效果的demo之类的。。。 哈哈，开个玩笑啦，第一时间去网上搜索不见得不好，汲取各个大神设计思路之精华嘛，不过我好想近期没这么做哦，因为被伤过，曾经也是一有问题就直接复制到网上和各个开发群询问，但大部分得到的反馈都是没人叼，记得收到回复最多的是这张图！有种被鄙视的感觉有没有。","text":"在审美疲劳的今天，如何能开发出一款应用让用户耳目一新呐，适当的动画特效能为你的APP加分不少，这一点在海外的APP上表现颇为明显。今天为大家带来一篇实用的自定义view，就是是TextView实现文字逐个显示（类似打印机打字一样，逐个显示的效果）。 按照惯例，无图无真相 1、开篇在开始讲解之前先问一下大家，看到这样的一个动画效果，脑海中首先先闪的思路是什么，如果你的UI设计师让你去实现的话，你要怎么做呐，希望读者在思考片刻之后再继续阅读，看看我们的设计思路是不是一样，如果不一样比较一下哪种实现起来更方便，哪种效率更高，欢迎评论交流。你有一个思想，我有一个思想，交换一下我们都有两个思想。 当你读到这里的时候说明你应该思考过上边的问题了，就问你第一想法是不是网上搜相关资料，看看有没有现成的，有的话直接拿来，没的话换个方式继续搜索。。。比如到各个开发群里询问有没有类似效果的demo之类的。。。 哈哈，开个玩笑啦，第一时间去网上搜索不见得不好，汲取各个大神设计思路之精华嘛，不过我好想近期没这么做哦，因为被伤过，曾经也是一有问题就直接复制到网上和各个开发群询问，但大部分得到的反馈都是没人叼，记得收到回复最多的是这张图！有种被鄙视的感觉有没有。 2、实现 扯了半天蛋，终于步入正题了。 其实这样的效果实现思路还是挺多的，有的是动态生成多个TextView,每次设置一个字符控制显示隐藏，有的继承自View完全自定义，从头绘制到底。这里我的方式是继承自TextView，我们只需实现文字逐个显示的效果的逻辑就ok了，至于设置文字颜色，字体大小之类的属性我们直接使用TextView自己属性就好了，这样大大简化了我们的开发流程。 实现步骤： 1、重写onDraw方法，绘制文字2、利用属性动画在固定时间内重绘显示的文字3、封装并暴露外部调用的方法 2.1 、重绘文字1234567@Overrideprotected void onDraw(final Canvas canvas) &#123; super.onDraw(canvas); if (stringBuffer != null) &#123; drawText(canvas, stringBuffer.toString()); &#125;&#125; stringBuffer就是需要绘制的文字12345678910111213141516/** * 绘制文字 * * @param canvas 画布 */private void drawText(Canvas canvas, String textString) &#123; //设置文字绘制的区域 textRect.left = getPaddingLeft(); textRect.top = getPaddingTop(); textRect.right = getWidth() - getPaddingRight(); textRect.bottom = getHeight() - getPaddingBottom(); Paint.FontMetricsInt fontMetrics = getPaint().getFontMetricsInt(); int baseline = (textRect.bottom + textRect.top - fontMetrics.bottom - fontMetrics.top) / 2; //文字绘制到整个布局的中心位置 canvas.drawText(textString, getPaddingLeft(), baseline, getPaint());&#125; 看过我之前写的那几篇文章的朋友会发现我们自定义view系列的文章基本都有这个方法，可以封装一下，以后在任何需要使用的地方都可以拿来直接使用。这个方法没什么复杂的逻辑我们不过多解读了。 2.2、利用属性动画动态改变绘制的文字代码很好理解先上代码，跟着代码我们去学习实现思路1234567891011121314151617181920212223242526272829303132/** * 文字逐个显示动画 通过插值的方式改变数据源 */ private void initAnimation() &#123; //从0到textCount - 1 是设置从第一个字到最后一个字的变化因子 textAnimation = ValueAnimator.ofInt(0, textCount - 1); //执行总时间就是每个字的时间乘以字数 textAnimation.setDuration(textCount * duration); //匀速显示文字 textAnimation.setInterpolator(new LinearInterpolator()); textAnimation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; int index = (int) valueAnimator.getAnimatedValue(); //过滤去重，保证每个字只重绘一次 if (currentIndex != index) &#123; stringBuffer.append(arr[index]); currentIndex = index; //所有文字都显示完成之后进度回调结束动画 if (currentIndex == (textCount - 1)) &#123; if (textAnimationListener != null) &#123; textAnimationListener.animationFinish(); &#125; &#125; invalidate(); &#125; &#125; &#125;); &#125; 思路是这样的：为每个文字显示的时间设置一个固定值duration，我这里默认显示300毫秒，动画执行的总时间就是总共的字数乘以每个字显示的时间（ textCount * duration），ValueAnimator.ofInt(0, textCount - 1)是为了根据这个字数的因子当做下标获取单个字符，每次追加到 stringBuffer.append(arr[index])，代码中我做了过滤重绘的判断，保证每次只绘制一遍，提升性能，因为我们的valueAnimator.getAnimatedValue()这个变化因子会不断变化及时转成int类型，每次也是有很多重复的，所以去重这一步就显得格外重要，我们可以看一下打印日志。 看到这里其估计有人会问怎么设置要显示的字符串呐还有arr[index]十个什么鬼，不要着急，继续往下看就明白了1234567891011121314151617181920/** * 设置逐渐显示的字符串 * * @param textString * @return */public FadeInTextView setTextString(String textString) &#123; if (textString != null) &#123; //总字数 textCount = textString.length(); //存放单个字的数组 arr = new String[textCount]; for (int i = 0; i &lt; textCount; i++) &#123; arr[i] = textString.substring(i, i + 1); &#125; initAnimation(); &#125; return this;&#125; 我把传入的字符串都存放到一个数组里边每次根据index去取相应的字符，好啦，到此这个功能的实现已经完成了。 3、对外暴露的方法设置字符的方法少不了，接下来开启动画和停止动画，然后就是动画结束的回调。12345678910111213141516171819202122232425262728293031323334 /** * 开启动画 * * @return */public FadeInTextView startFadeInAnimation() &#123; if (textAnimation != null) &#123; //动画开启的时候参数都设置成初始状态 stringBuffer.setLength(0); currentIndex = -1; textAnimation.start(); &#125; return this;&#125;/** * 停止动画 * * @return */public FadeInTextView stopFadeInAnimation() &#123; if (textAnimation != null) &#123; textAnimation.end(); &#125; return this;&#125;/** * 回调接口 */public interface TextAnimationListener &#123; void animationFinish();&#125; 4、如何使用123456789fadeInTextView .setTextString(&quot;自定义view实现字符串逐字显示&quot;) .startFadeInAnimation() .setTextAnimationListener(new FadeInTextView.TextAnimationListener() &#123; @Override public void animationFinish() &#123; &#125; &#125;); 至此本篇文章的介绍已经结束，接下来会继续推出相关系列的文章。小功能大智慧，功能再小还要新手敲一敲，不然。。。不然。。。看图意会吧，哈哈😆! github源码地址传送门 谨以此篇来记录自己项目中遇到的问题，献给需要类似功能的小伙伴们。如果你有好的建议欢迎评论指出，大家一起讨论、学习、进步！","categories":[],"tags":[]},{"title":"Android实用view系列------炫酷的进度条","slug":"Android实用view系列-炫酷的进度条","date":"2017-06-03T08:23:36.000Z","updated":"2017-09-07T04:24:53.554Z","comments":true,"path":"2017/06/03/Android实用view系列-炫酷的进度条/","link":"","permalink":"https://github.com/lygttpod/2017/06/03/Android实用view系列-炫酷的进度条/","excerpt":"不知不觉距离上次写文章已经过去大半个月了，原本计划每周写一篇的想法在坚持几周之后最终还是被生活中各种各样的琐事打乱，无奈中夹杂这对自己的一点失望。当初的愿望实现了吗事到如今只好祭奠吗任岁月风干理想再也找不回真的我抬头仰望着满天星河那时候陪伴我的那颗这里的故事你是否还记得 今天给大家带来的是自定义view系列之炫酷的进度条的效果，让你的进度条从此与众不同。 按照惯例先上效果图，俗话说无图无有真相嘛。 我们可以看出来这其实就是一个进度条，此时的你或许心生疑惑，MD一个进度条有什么好说的，无论是官方的ProgressBar的还是GitHub开源的一抓一大把，这有什么好讲的。有这样的想法很正常，毕竟我曾经看别人写的文章的时候也会冒出这样的想法。 那么我为什么还要写呐，首先并不是我们所有的需求都能在网上找到，其次，即使找到类似的代码修修补补也能用，但对我们的提升并不大，作为一名合格的开发人员只有亲手撸出来的代码用着才踏实嘛，我们是抱着学习的心态看问题，分析问题，并解决它的。","text":"不知不觉距离上次写文章已经过去大半个月了，原本计划每周写一篇的想法在坚持几周之后最终还是被生活中各种各样的琐事打乱，无奈中夹杂这对自己的一点失望。当初的愿望实现了吗事到如今只好祭奠吗任岁月风干理想再也找不回真的我抬头仰望着满天星河那时候陪伴我的那颗这里的故事你是否还记得 今天给大家带来的是自定义view系列之炫酷的进度条的效果，让你的进度条从此与众不同。 按照惯例先上效果图，俗话说无图无有真相嘛。 我们可以看出来这其实就是一个进度条，此时的你或许心生疑惑，MD一个进度条有什么好说的，无论是官方的ProgressBar的还是GitHub开源的一抓一大把，这有什么好讲的。有这样的想法很正常，毕竟我曾经看别人写的文章的时候也会冒出这样的想法。 那么我为什么还要写呐，首先并不是我们所有的需求都能在网上找到，其次，即使找到类似的代码修修补补也能用，但对我们的提升并不大，作为一名合格的开发人员只有亲手撸出来的代码用着才踏实嘛，我们是抱着学习的心态看问题，分析问题，并解决它的。 说了那么多废话下边就开始步入正题吧 如果真是一个简简单单的进度条的话确实没什么好讲的，仔细观察效果图后你会发现其实还是有点内容的，麻雀虽小五脏俱全。 这里边有几个点需要说明一下：①、进度条有动画效果②、进度条上边有个百分比的样式的绘制③、百分比tip框跟随进度条移动需要注意的事项 1、带动画的进度条效果因为我们是自定义view，看到的所有元素都是在onDraw里边绘制出来的，分析进度条效果我们可以分解出几个步骤，先绘制底层百分百进度条（也就是背景色），再绘制真实的进度。1234567891011121314151617181920@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // tipHeight + progressMarginTop其实是把进度条绘制到百分比tip框的下边 // 这里只是给出大概的计算，如有需求可以精确计算高度 //绘制背景 canvas.drawLine(getPaddingLeft(), tipHeight + progressMarginTop, getWidth(), tipHeight + progressMarginTop, bgPaint); //绘制真实进度 canvas.drawLine(getPaddingLeft(), tipHeight + progressMarginTop, currentProgress, tipHeight + progressMarginTop, progressPaint);&#125; 进度条画完之后就是让它动起来，我们使用属性动画试试改变当前进度的值重新绘制就可以了，动画效果我们继续使用ValueAnimator12345678910111213141516171819202122232425/** * 进度移动动画 通过插值的方式改变移动的距离 */ private void initAnimation() &#123; progressAnimator = ValueAnimator.ofFloat(0, mProgress); progressAnimator.setDuration(duration); progressAnimator.setStartDelay(startDelay); progressAnimator.setInterpolator(new LinearInterpolator()); progressAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; float value = (float) valueAnimator.getAnimatedValue(); //这是我们自己的需求进度只显示整数 textString = formatNum(format2Int(value)); //百分比的进度转换成view宽度一样的比例 currentProgress = value * mWidth / 100; //进度回调方法 if (progressListener != null) &#123; progressListener.currentProgressListener(value); &#125; invalidate(); &#125; &#125;); progressAnimator.start(); &#125; 到此带动画的进度条就实现了，一起看一下效果吧 2、绘制上边的百分比布局 看到这个百分比的提示框，你会想到如何实现呐，很多人会选择使用图片然后变更图片的位置来达到效果，作为一个有追求的程序猿怎能满足于此呐，自己绘制出来岂不更好。接下来我们来分析一下如何绘制这个带三角的矩形 这里说一下我们实现思路：其实第一次我是准备从起点到终点用过画闭合的线做的，需要计算七个点的坐标，最终能实现，但是这种方法太笨了，根本拿不出手哦 在苦思的时候突然又看了一眼设计图发现这个矩形是带圆角的，我这样绘制闭合的线是达不到圆角效果的，等等，圆角？圆角不是可以通过绘制圆角矩形画出来么，我擦，貌似这是一个不错的思路，赶紧去验证。 果不其然，堪称完美，先绘制一个圆角矩形，在其下边绘制一个三角形，至于里边的进度数值直接drawText就行了12345678910111213141516171819202122232425262728293031323334/** * 绘制进度上边提示百分比的view * * @param canvas */private void drawTipView(Canvas canvas) &#123; drawRoundRect(canvas); drawTriangle(canvas);&#125;/** * 绘制圆角矩形 * * @param canvas */private void drawRoundRect(Canvas canvas) &#123; rectF.set(moveDis, 0, tipWidth + moveDis, tipHeight); canvas.drawRoundRect(rectF, roundRectRadius, roundRectRadius, tipPaint);&#125;/** * 绘制三角形 * * @param canvas */private void drawTriangle(Canvas canvas) &#123; path.moveTo(tipWidth / 2 - triangleHeight + moveDis, tipHeight); path.lineTo(tipWidth / 2 + moveDis, tipHeight + triangleHeight); path.lineTo(tipWidth / 2 + triangleHeight + moveDis, tipHeight); canvas.drawPath(path, tipPaint); path.reset();&#125; 3、计算百分比Tip框的起始位置及移动分析样式绘制出来接下来就是各种计算了，先来张手绘图凑合着看哈 担心图片不清晰就再对图片内容描述一下，重要信息有四个，进度的起始点A和B、tip框的起始点M和N，动画执行过程是这样的：刚开始的时候只有进度条移动，此时tip框是不动的，当进度条到达tip框中间三角形顶点x坐标的时候，tip框跟着进度开始一起移动，当tip框右边界到达整个进度的右边界的时候，tip框停止移动，进度条继续移动一直到终点。 1234567891011121314151617181920212223242526272829303132/** * 进度移动动画 通过插值的方式改变移动的距离 */ private void initAnimation() &#123; progressAnimator = ValueAnimator.ofFloat(0, mProgress); progressAnimator.setDuration(duration); progressAnimator.setStartDelay(startDelay); progressAnimator.setInterpolator(new LinearInterpolator()); progressAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; float value = (float) valueAnimator.getAnimatedValue(); //进度数值只显示整数，我们自己的需求，可以忽略 textString = formatNum(format2Int(value)); //把当前百分比进度转化成view宽度对应的比例 currentProgress = value * mWidth / 100; //进度回调方法 if (progressListener != null) &#123; progressListener.currentProgressListener(value); &#125; //移动百分比提示框，只有当前进度到提示框中间位置之后开始移动， //当进度框移动到最右边的时候停止移动，但是进度条还可以继续移动 //moveDis是tip框移动的距离 if (currentProgress &gt;= (tipWidth / 2) &amp;&amp; currentProgress &lt;= (mWidth - tipWidth / 2)) &#123; moveDis = currentProgress - tipWidth / 2; &#125; invalidate(); &#125; &#125;); progressAnimator.start(); &#125; 最终实现的效果 写在最后到此本篇文章终点部分已经结束，按照惯例应该做下总结的，但今天并没有这个打算(毕竟文章里边技术点描述的很清楚了，哈哈😆)。这里就分享一下我的一些看法吧，敲代码其实是一件很枯燥的事，每天面对一大堆字母时间久了或多或少会心烦，那么我们怎样才能保持一个好的状态去coding呐，培养自己的兴趣，兴趣真的很重要，有了兴趣你会把敲代码当做生活的一部分而不仅仅是工作。这样生活才有意义，否则时间久了真的会颓废。 github源码地址传送门 谨以此篇来记录自己项目中遇到的问题，献给需要类似功能的小伙伴们。如果你有好的建议欢迎评论指出，大家一起讨论、学习、进步！","categories":[],"tags":[]},{"title":"Android实用View系列-----仿微信支付宝等风格的支付密码输入框的实现","slug":"Android实用View系列-仿微信支付宝等风格的支付密码输入框的实现","date":"2017-05-07T08:23:13.000Z","updated":"2017-09-07T04:24:41.010Z","comments":true,"path":"2017/05/07/Android实用View系列-仿微信支付宝等风格的支付密码输入框的实现/","link":"","permalink":"https://github.com/lygttpod/2017/05/07/Android实用View系列-仿微信支付宝等风格的支付密码输入框的实现/","excerpt":"开始阅读本篇文章之前先来说一下使用场景吧，我们知道如今移动支付已经占据我们日常支付的90%的份额，以微信支付和支付宝支付为主，也越来越多的APP开始添加支付模块，不管使用哪种支付有一个步骤是少不了的，那就是输入支付密码(指纹支付再此就不做讨论了哦)，所以今天来给大家带来一篇自定义支付密码输入框的设计和实现方式，同时记录自己工作中遇到的问题及解决办法。 github源码地址传送门 按照惯例我们先看看微信和支付宝支付密码输入框的样式吧","text":"开始阅读本篇文章之前先来说一下使用场景吧，我们知道如今移动支付已经占据我们日常支付的90%的份额，以微信支付和支付宝支付为主，也越来越多的APP开始添加支付模块，不管使用哪种支付有一个步骤是少不了的，那就是输入支付密码(指纹支付再此就不做讨论了哦)，所以今天来给大家带来一篇自定义支付密码输入框的设计和实现方式，同时记录自己工作中遇到的问题及解决办法。 github源码地址传送门 按照惯例我们先看看微信和支付宝支付密码输入框的样式吧 看到这样的效果相信很多开发者第一反应就是先网上搜一下看看有没有现成的（哈哈，我也不例外哦），因为这都是简单的一些view不涉及动画所以网上相关例子还是很多的，我这边总结了一下大致可以分为一下几类1、通过布局的方式： 在布局里边放置6个EditView,在每个输入框中间再放置一个view用于设置中间分割线，每个EditVIew只允许输入一个字符，然后对每个进行监听，一个密码输入完之后让另一个EditView获取焦点，以此类推就可以大致实现图中的效果了（这样确实可以实现，实现起来也很简单，但是代码量不少，而且这种方式是不是显得逼格不够高或者没有逼格呐） 2、完全自定义view（继承View）： 这个就稍微复杂一点，大致流程是，先监听触摸事件，按下时弹出键盘，然后对软键盘进行监听，获取每次点击键盘对应的字符串，然后在onDraw方法里边画6个圆，在绘制外边框，然后是中间的分割线。这里边有个问题就是每次都要对软键盘进行监听取值等一系列操作，加上Android机型众多整不好哪块软键盘就出问题了呐。（虽然有逼格，但是不实用哦） 3、继承自EditView实现自定义view: 大致流程和上一种差不多，不过我们不需要对软键盘进行处理了,少了很多繁琐及兼容性的操作，同时又不失逼格，哈哈。 看到以上三种实现方式想必你大概已经知道我们要使用哪种方式实现了，没错就是集成EditView的自定义view,这样我们还可以使用很多EditView的属性哦开发前先整理一下实现步骤： 1、绘制外边框（可以是直角也可以是圆角，设计师要什么我们就给他什么）2、绘制密码之间的分割线（竖线）3、绘制实心圆代替输入的字符4、对输入字符进行监听，便于扩展处理5、实现一些常用的外部接口方法调用 具体实现1、绘制外边框：要想绘制边框我们首先要知道view的宽高，通过onSizeChanged方法去初始化宽高等数据，然后绘制圆角矩形（默认让他矩形显示直接传入圆角半径为0即可）1234567891011121314151617@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); height = h; width = w; divideLineWStartX = w / maxCount; startX = w / maxCount / 2; //第一个圆心的x坐标 startY = h / 2; //第一个圆心的y坐标 bottomLineLength = w / (maxCount + 2); rectF.set(0, 0, width, height);&#125; 1234RectF rectF = new RectF()rectF.set(0, 0, width, height);canvas.drawRoundRect(rectF, rectAngle, rectAngle, borderPaint); 2、绘制密码之间的分割线：既然是分割线肯定是等均分的，假设我们的密码最大输入maxCount=6，那么我们只需画5个分割线就可以了，分割线坐标的计算 12345678通过循环画出每个分割线for (int i = 0; i &lt; maxCount - 1; i++) &#123; canvas.drawLine((i + 1) * divideLineWStartX, 0, (i + 1) * divideLineWStartX, height, divideLinePaint); &#125; 完成这一步我们先运行一下看看边框效果吧 3、绘制实心圆代替输入的字符：这里需要监听EditView的输入，重写onTextChanged方法获取输入字符的长度,然后计算每个圆圆心的坐标位置123456789101112131415161718 //第一个圆心的x坐标 startX = w / maxCount / 2; //第一个圆心的y坐标 startY = h / 2;/** * 画密码实心圆 * * @param canvas */private void drawPsdCircle(Canvas canvas) &#123; for (int i = 0; i &lt; textLength; i++) &#123; canvas.drawCircle(startX + i * 2 * startX, startY, radius, circlePaint); &#125;&#125; 写到这里的时候是不是感觉样式问题已经完成的差不多了，运行以来输入几个字符串一看，MD出问题了(看图说话)从图中可以看出是绘制了相应的实心圆，但是自带的底部线、光标、字符还在，要是拿这个去交差绝逼会被产品骂死。出现这个问题肯定是代码的问题喽，我们根据问题去一个一个解决，首先给view设置一个透明的背景色，然后隐藏光标，再跑一下看看12this.setBackgroundColor(Color.TRANSPARENT);this.setCursorVisible(false); 这次底部的线和光标都见了，但是输入的字符还在，这又是什么问题？？？我们明明重写了onDraw方法，怎么还会出现原来的字符呐，等等。。。对啊，我们只是重写，他肯定还有自己的方法，我们只要把EditView内部重绘的方法干掉不就行了，想到这里喜出望外，拿跟辣条先压压惊，在ondraw方法中这样做123456789101112 @Override protected void onDraw(Canvas canvas) &#123; //不删除的话会默认绘制输入的文字 // super.onDraw(canvas); &#125;你没看错，就是这一行代码注释掉就ok，至于是为什么你肯定知道，不注释的话在我们重写之前他已经调用了内部方法去绘制输入的字符了，我们在重写后虽然我们的方法生效了，但它的方法也生效了哦。 此时压抑不住内心的小激动赶紧运行起来看看（哈哈，完美解决问题） 至此主要功能已经完成，剩下的需要去封装一些方法供外部调用，我这里已经封装几个方法，我们知道这样设置支付密码的页面一般有两个：一个设置密码，一个重新设置密码，按照正常的逻辑我们去监听这个密码输入框，输入密码之后进行比较看是否相等就完事了，为了方便以后使用不要每次自己再去写一大堆监听方法，我们直接在内部封装好是不是对以后使用起来更方便一点呐12345678910111213/** * 密码比较监听 */ public interface onPasswordListener &#123; void onDifference(); void onEqual(String psd); &#125; //使用者需要调用的方法 public void setComparePassword(String comparePassword, onPasswordListener listener) &#123; mComparePassword = comparePassword; mListener = listener; &#125; 这里就直接上代码了,代码通俗易懂123456789101112131415@Overrideprotected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) &#123; super.onTextChanged(text, start, lengthBefore, lengthAfter); textLength = text.toString().length(); if (mComparePassword != null &amp;&amp; textLength == maxCount) &#123; if (TextUtils.equals(mComparePassword, getPasswordString())) &#123; mListener.onEqual(getPasswordString()); &#125; else &#123; mListener.onDifference(); &#125; &#125; invalidate();&#125; 实际使用中我们这样设置(是不是瞬间感觉用的过程简单了很多)1234567891011121314passwordInputView.setComparePassword(&quot;123456&quot;, new PayPsdInputView.onPasswordListener() &#123; @Override public void onDifference() &#123; // TODO: 2017/5/7 和上次输入的密码不一致 做相应的业务逻辑处理 Toast.makeText(MainActivity.this,&quot;两次密码输入不同&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void onEqual(String psd) &#123; // TODO: 2017/5/7 两次输入密码相同，那就去进行支付楼 Toast.makeText(MainActivity.this,&quot;密码相同&quot;+psd,Toast.LENGTH_SHORT).show(); &#125;&#125;); 文章到此本应该结束了，可是我们UI设计师给出的效果图不是这样子的，不按常理出牌（心中顿时飘过一万只草泥马） 来看看我们的效果图 他不按常量出牌，不过这也是他们一贯的作风，既然他们要这样的效果那我们就去做喽，整个流程还是一样的，唯一的不同就是外边框和密码之间的分割线变成了底部间断的线，这肯定难不倒我们啦，不就是画六条线吗，每根线的起点终点坐标和上边圆心左边计算差不多，就不多描述了看代码最实在123456789101112131415/** * 画底部显示的分割线 * * @param canvas */private void drawBottomBorder(Canvas canvas) &#123; for (int i = 0; i &lt; maxCount; i++) &#123; cX = startX + i * 2 * startX; canvas.drawLine(cX - bottomLineLength / 2, height, cX + bottomLineLength / 2, height, bottomLinePaint); &#125;&#125; 项目至此完美收工，看看效果吧 最后总结 以上微信支付密码和我们这种现实效果我都封装在PayPsdInputView中了，可以根据需求切换不同的样式，如果以后还要其他的支付密码输入的样式的话同样会添加进来的，目的只有一个———&gt;下次开发省时省力。 番外篇 我相信看到这里肯定有一部分小伙伴会说MDZZ,这不就是简单的画矩形、画圆、画线吗，有什么好写的，谁都会做。我想说的是你们说的没错，涉及的知识点是很简单，但是不要忘了，麻雀虽小五腑俱全，真正你去一行一行敲的时候你会发现有很多不曾注意过的问题都会浮出水面。只是单纯的会几个知识点其实没什么卵用，把所学知识点运用起来重组成一个功能模块的时候你才算真正的掌握。 谨以此篇来记录自己项目中遇到的问题，献给需要类似功能的小伙伴们。如果你有好的建议欢迎评论指出，大家一起讨论、学习、进步！","categories":[],"tags":[{"name":"Android View 自定义","slug":"Android-View-自定义","permalink":"https://github.com/lygttpod/tags/Android-View-自定义/"}]},{"title":"Android自定义动画酷炫的提交按钮","slug":"Android自定义动画酷炫的提交按钮","date":"2017-04-29T08:22:17.000Z","updated":"2017-09-07T04:25:19.459Z","comments":true,"path":"2017/04/29/Android自定义动画酷炫的提交按钮/","link":"","permalink":"https://github.com/lygttpod/2017/04/29/Android自定义动画酷炫的提交按钮/","excerpt":"今天开始记录工作中遇到的需要实现的动画效果实现自定义view动画，后期会有一些列动画设计思路的文章。 在这里分享的是设计实现思路，仅供学习使用，让大家拿到稍微复杂点的动画的时候要知道该如何去一步步分解实现，而不是抱怨下边就先来看看设计需要的效果图及我们最终实现的效果图，毕竟有图有真相嘛！ 其实我刚拿到设计图的时候心想，MD直接给一张gif图不就行了何必这个麻烦呐，随后冷静下来之后（其实就是抱怨之后）想想作为一名Android开发者总不能什么动画都依赖设计师吧，那样的话会显得我们开发者没什么卵用啊，说不定还会被设计师鄙视哦，于是就开始了动画分析及实现之旅。","text":"今天开始记录工作中遇到的需要实现的动画效果实现自定义view动画，后期会有一些列动画设计思路的文章。 在这里分享的是设计实现思路，仅供学习使用，让大家拿到稍微复杂点的动画的时候要知道该如何去一步步分解实现，而不是抱怨下边就先来看看设计需要的效果图及我们最终实现的效果图，毕竟有图有真相嘛！ 其实我刚拿到设计图的时候心想，MD直接给一张gif图不就行了何必这个麻烦呐，随后冷静下来之后（其实就是抱怨之后）想想作为一名Android开发者总不能什么动画都依赖设计师吧，那样的话会显得我们开发者没什么卵用啊，说不定还会被设计师鄙视哦，于是就开始了动画分析及实现之旅。 通过这个gif动画我们分析出动画过程的实质： 一个长方形（或者是圆角长方形）逐渐过渡成为两边是半圆的长方形，于此同时长方形两边向中间靠拢最终形成一个圆，然后圆上升一定高度，最后在圆里边画出对勾(✔).整个动画分解的其实就是这几个部分，那么我们该如何实现呐，不要捉急，继续往下看。 第一步：我们要先画出一个圆角矩形吧1234567891011121314151617/** * 绘制带圆角的矩形 * * @param canvas 画布 */ private void draw_oval_to_circle(Canvas canvas) &#123; //这里是对矩形的位置大小的设置 rectf.left = two_circle_distance; rectf.top = 0; rectf.right = width - two_circle_distance; rectf.bottom = height; //画圆角矩形 canvas.drawRoundRect(rectf, circleAngle, circleAngle, paint); &#125; 圆角矩形绘制完成之后就是改变圆角半径的大小使其两边形成半圆的效果，那么怎么才能让他成为半圆呐，来看看一张图，若要绘制成半圆效果，那么这个圆的直径就是view自身的高度，那么这个圆的半径就是height/2 123456789101112131415/** * 设置矩形过度圆角矩形的动画 */private void set_rect_to_angle_animation() &#123; animator_rect_to_angle = ValueAnimator.ofInt(0, height / 2); animator_rect_to_angle.setDuration(duration); animator_rect_to_angle.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; circleAngle = (int) animation.getAnimatedValue(); invalidate(); &#125; &#125;);&#125; 添加动画之后的效果如下 第二步：当矩形两边都是半圆之后就要处理使其向中间靠拢逐渐形成一个圆，那么问题又来了，需要向中间移动多少呐，并且怎么移动才能使两边都想中间聚拢呐下边来看一张图分析一下 有图可知移动的距离是(width-height)/2,然后在写一个动画让其改变距离最终两个半圆靠拢在一起形成圆123456789101112131415161718192021/** * 设置圆角矩形过度到圆的动画 * default_two_circle_distance = (w-h)/2 */private void set_rect_to_circle_animation() &#123; animator_rect_to_square = ValueAnimator.ofInt(0, default_two_circle_distance); animator_rect_to_square.setDuration(duration); animator_rect_to_square.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; two_circle_distance = (int) animation.getAnimatedValue(); //在靠拢的过程中设置文字的透明度，使文字逐渐消失的效果 int alpha = 255 - (two_circle_distance * 255) / default_two_circle_distance; textPaint.setAlpha(alpha); invalidate(); &#125; &#125;);&#125; 完成上边代码后再来看下效果 第三步：让圆上移移动距离。这个移动很好实现,直接改变Y轴方法的坐标就行了，这个很简单就直接看代码吧123456789/** * 设置view上移的动画 */private void set_move_to_up_animation() &#123; final float curTranslationY = this.getTranslationY(); animator_move_to_up = ObjectAnimator.ofFloat(this, &quot;translationY&quot;, curTranslationY, curTranslationY - move_distance); animator_move_to_up.setDuration(duration); animator_move_to_up.setInterpolator(new AccelerateDecelerateInterpolator());&#125; 第四步：在圆中绘制一个对勾，而且是带动画的对勾，让对勾以动画的形式慢慢绘制出来如果对相关API不熟悉的话不知道会怎么去实现呐，或许你会想通过绘制线的方式，在对勾起点开始不断改变移动点的坐标进行绘制，那么怎么获取这些点的坐标呐，这里我们使用Path和DashPathEffect两个方法实现，对DashPathEffect不了解的小伙伴可以去查一下文档哦 DashPathEffect这个类的作用就是将Path的线段虚线化。构造函数为DashPathEffect(float[] intervals, float offset)，其中intervals为虚线的ON和OFF数组，该数组的length必须大于等于2，phase为绘制时的偏移量。 我们先拿到对勾的path路径在对其改变偏移量加上DashPathEffect就能实现动态绘制对勾的效果了，那么怎么计算对勾的起点折点和终点的坐标呐，在网上找了一个不错的图片，如果你的设计师直接把位置给你标明的很详细的话你就省了这些自己计算的麻烦 1234567891011121314/** * 绘制对勾 * 下边计算比例是参考网上一些例子加上自己一步一步尝试的出来的比例，仅供参考 * 如果条件允许最好还是让设计师给你标明一下比例哦！ */ private void initOk() &#123; //对勾的路径 path.moveTo(default_two_circle_distance + height / 8 * 3, height / 2); path.lineTo(default_two_circle_distance + height / 2, height / 5 * 3); path.lineTo(default_two_circle_distance + height / 3 * 2, height / 5 * 2); pathMeasure = new PathMeasure(path, true); &#125; 123456789101112131415161718/** * 绘制对勾的动画 */private void set_draw_ok_animation() &#123; animator_draw_ok = ValueAnimator.ofFloat(1, 0); animator_draw_ok.setDuration(duration); animator_draw_ok.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; startDrawOk = true; float value = (Float) animation.getAnimatedValue(); effect = new DashPathEffect(new float[]&#123;pathMeasure.getLength(), pathMeasure.getLength()&#125;, value * pathMeasure.getLength()); okPaint.setPathEffect(effect); invalidate(); &#125; &#125;);&#125; 再来看效果 至此动画分解都已完成，但是机智的你应该已经发现问题了，就是感觉动画播放衔接的不是很好，那么接下来我们就处理这个问题，回到最初的效果图上，矩形变圆角和缩放成圆形是同时进行的，那么我们有什么办法可以实现动画同时播放呐，哈哈，身为老司机的想必已经知道了使用AnimatorSet，他可以播放动画集、顺序播放等，那么我们就开始处理吧 我们让矩形变圆角和矩形往中间缩放同时进行，然后圆在上移，最后绘制对勾 12345animatorSet .play(animator_move_to_up) .before(animator_draw_ok) .after(animator_rect_to_square) .after(animator_rect_to_angle); 最终奉上我们自己一步一步完整实现的效果图 至此我们可以理直气壮地带着作品找设计师互怼了 总结：看到这里是不是觉得这样的动画实现起来也不是很复杂嘛，也许你会觉得这样的动画没什么技术含量，实现起来真的没什么难度，何必再此大做文章呐，其实我这里也只是个抛砖引玉的作用，提供一种学习方法，也许今天我们遇到的只是一个简单的动画，可明天如果需要我们去做更复杂的动画呐，我们该怎么处理，怎么分析，怎么实现呐。只要我们把自己的需求分析拆解，把复杂的步骤简单化，分布实现在组合到一起就可以实现自己想要的效果（你要知道炫酷的电影特效也是一帧一帧动画合成的哦）。 源码已经上传到github上了，需要参考学习的点击传送门哦","categories":[],"tags":[]},{"title":"RecyclerView通过GridLayoutManager实现多样式布局","slug":"RecyclerView通过GridLayoutManager实现多样式布局","date":"2017-04-15T08:22:44.000Z","updated":"2017-09-07T04:25:42.435Z","comments":true,"path":"2017/04/15/RecyclerView通过GridLayoutManager实现多样式布局/","link":"","permalink":"https://github.com/lygttpod/2017/04/15/RecyclerView通过GridLayoutManager实现多样式布局/","excerpt":"一、开篇距离上次写文章已经有段时间了，说实话真不知道最近在忙些什么，现在沉下心来把最近项目中遇到的问题记录下来便于以后遇到中使用吧！废话不多说，先看一下效果图 ###二、需求解析1、先说下项目需求，不管是好评还是差评下边的Tag标签有不同的展示类型，有的字数多的会单独占一行处理（这边其实也可以扩充，比如说两三个字的可以一行显示三个Tag标签），第一眼看到这个需求准备使用网上的开源库TagLayout去实现，但是尝试了一下后发现其实他们实现的效果同项目要的效果还是有蛮大差距的，可以看到效果图里边是要求文字是居中对齐的，左右对称的。2、想到使用GridView实现这个功能，定义adapter去实现没问题，问题是什么时候显示一行什么时候显示两行三行并不能确定，毕竟有时候服务端返回的没有类型标示只有tag_name和tag_id，你要根据什么设置类型呐，而且自从recyclerview之后现在要是还用GridView的话岂不是太落伍了。下边就重点介绍一下使用recyclerview实现如图效果。","text":"一、开篇距离上次写文章已经有段时间了，说实话真不知道最近在忙些什么，现在沉下心来把最近项目中遇到的问题记录下来便于以后遇到中使用吧！废话不多说，先看一下效果图 ###二、需求解析1、先说下项目需求，不管是好评还是差评下边的Tag标签有不同的展示类型，有的字数多的会单独占一行处理（这边其实也可以扩充，比如说两三个字的可以一行显示三个Tag标签），第一眼看到这个需求准备使用网上的开源库TagLayout去实现，但是尝试了一下后发现其实他们实现的效果同项目要的效果还是有蛮大差距的，可以看到效果图里边是要求文字是居中对齐的，左右对称的。2、想到使用GridView实现这个功能，定义adapter去实现没问题，问题是什么时候显示一行什么时候显示两行三行并不能确定，毕竟有时候服务端返回的没有类型标示只有tag_name和tag_id，你要根据什么设置类型呐，而且自从recyclerview之后现在要是还用GridView的话岂不是太落伍了。下边就重点介绍一下使用recyclerview实现如图效果。 ###三、功能实现我们知道recyclerview实现GridView效果只需配置一下参数就行了 GridLayoutManager layoutManage = new GridLayoutManager(getContext(), 2); recycerView.setLayoutManager(layoutManage); 可以看到GridLayoutManager需要传递两个参数，一个是上下文对象，另一个是一行显示几列的参数常量，既然这个常量可以指定那么是不是这个值可以去控制呐，答案当然是yes 我们会注意到GridLayoutManager里边有个setSpanSizeLookup方法,本篇的重点就是这个方法（这个方法具体意义大家可以网上搜索，会有很多相关介绍，以及通过它实现一些复杂的布局，再次不做过多讨论） layoutManage.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { return 0; } }); 其实getSpanSize返回值就是控制每行有几列的，根据这个思路我们不妨试试。因为recyclerview填充数据是根据adapter实现的，我们就把给adapter的数据源同样在setSpanSizeLookup这个方法里边判断一下不就行了吗？根据这个思路于是有了下面的代码 /** * 如果单个item显示的字数大于指定某个值就显示一列 默认2列 */ //设置item数据大于多少字只显示一行 默认 超过九个字的程度只显示一列 private static final int MAX = 9; private int setSpanSize(int position, List&lt;TagBean&gt; listEntities) { int count; if (listEntities.get(position).getTag_name().length() &gt; MAX) { count = 2; } else { count = 1; } return count; } layoutManage.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { return setSpanSize(position,list); } }); 核心代码就这么多，我们可以根据自己的需求随意定制样式 最后奉上源码地址：https://github.com/lygttpod/AndroidCustomView","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://github.com/lygttpod/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-01T08:19:08.000Z","updated":"2017-08-29T08:34:15.043Z","comments":true,"path":"2017/04/01/hello-world/","link":"","permalink":"https://github.com/lygttpod/2017/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}